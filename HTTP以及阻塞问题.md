### HTTP状态码：

-  1xxx （临时响应):表示临时响应需要请求者继续执行操作的状态码

  - 100 (继续) 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分

    ​    正在等待其余部分

  - 101（切换协议）请求者已要求父亲切换协议，服务器已确认并准备切换

- 2xxx（成功）   表示成功处理了请求的状态码

  - 200（成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
  - 201（已创建）请求成功并且服务器创建了新的资源
  - 202（已接受）请求成功。但是没有处理
  - 203（非授权信息）服务器已成功处理了请求，但返回的信息可能来自另一来源
  - 204（无内容）服务器成功处理了请求但是没有返回任何内容 

-  3xxx(重定向)：要完成请求，需要进一步操作。通常，这些状态码用来重定向

  - 300（多种操作）针对请求，服务器可以执行多种操作。服务器可根据请求者选择一项操作，

    或提供操作列表供请求者选择。

  - 301（永久移动）请求的网页已用永久移动到新的位置，服务器返回此响应时，会自动将请求者

    转到新的位置。

  - 302（临时重定向）服务器目前从不同位置的网页响应请求，但是请求者应继续使用原来的位置来

    响应以后的请求

  - 303（查看其他位置）查看其它地址。与301类似。使用GET和POST请求查看

  - 304（未修改）。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，

     通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源，一般是从缓存中获取

- 4xxx（请求错误）：这些状态码表示请求可能出错，妨碍了服务器的处理

  - 400（错误）服务器不理解请求的语法
  - 401（未授权）请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应
  - 403（禁止）服务器拒绝请求
  - 404（未找到）服务器找不到请求的网页，网页不存在

- 5xxx（服务器错误）这些状态码表示服务器在处理请求的时候发生内部错误，这些错误可能是服务器本身的错误

  - 500(服务器内部错误)服务器遇到错误，无法完成请求

### post和get区别

- get参数通过url传递，post参数放在request body中

- get请求在url中传递的参数是有长度限制的，而post是没有的

- get比post更加不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息

- get请求只能进行url编码，而post支持多种编码方式

- get请求参数会被完整的保留在浏览历史记录里面，而post的参数不会被保留

- get产生一个TCP数据包；而post参数2个TCP数据包。对于GET方式的请求。浏览器会把

  http header和data一并发出去，服务器响应200（返回数据），而post，浏览器先发http header服务器

  返回100（继续）浏览器在发送header，服务器响应200 ok

### HTTP协议中的缓存处理流程

  缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定

- 强缓存是利用http头中的Expires和cache-Control两个字段控制前者是http1.0时的规范，他的值为绝对时间的字符串

  如果发送时间在expires之前，本地缓存始终有效 ，还有一个cache-Control他是http1.1的规范，他有一个值规定了有效时间长度

  还有一个no-cache：表示不使用本地缓存，需要使用协商缓存，先与服务器确定是否被修改，然后是下面的协商缓存的部分了

- 协商缓存就是由服务器来确定缓存资源是否可用，也就是上面说的cache-Control为no-cache时走协商缓存

### 输入URL后发生了什么

1.DNS域名解析；2.建立TCP连接；3.发送HTTP请求；4.服务器处理请求； 5.返回响应结果；6.关闭TCP连接；7.浏览器解析HTML；8.浏览器布局渲染

详细过程（我的理解哈）

一、DNSS解析（优先从缓存中加载）

1.找浏览器DNS缓存解析域名

2.找本机DNS缓存

3.找路由DNS缓存

4.找运营商DNS缓存

5.递归查询

二、建立TCP连接即三次握手（我的理解）

  第一次握手：由浏览器发给服务器：我想和你说话 你听的见吗

  第二次握手：由服务器发给浏览器，我能听见  你说吧

  第三次握手：由浏览器发给服务器，好，我说话了

三、发送请求

四、得到响应

五、预解析html

  预解析就是优先发请求

解析html生成DOM树

解析css生成css树

合并成render树

​     js是否操作了DOM

   如果有（一般都会有）

 进行重绘回流操作

最终展示

六、断开连接即四次挥手 

第一次挥手：由浏览器发给服务器：我的东西接收完了，你断开连接吧

第二次挥手：由服务器发给浏览器 ：我还有东西没接收呢（比如他也在收到其他的请求或者处理），等会  （或者是他确定发送的响应 是否完整）

第三次挥手： 由服务器发给浏览器：我接受完了，你断开吧

第四次挥手：由浏览器发给服务器：好的我断开了 

其中第二步必不可少 因为要验证数据的完整性  这也是为什么  握手要三次，挥手要四次，握手时只要确保握手就可以了，挥手时，正在进行数据的传输，为了确保原数据的完整性必须多经历一次验证

### 关于构建DOM树时的阻塞问题

一个渲染引擎主要包括了HTML  CSS解析器      JS引擎         布局模块（layout） 和绘图模块

​    其中 HTML解析器是异步的  CSS解析器是同步的

就是说当我们遇到解析到样式时先发请求，然后请css解析器来解析css 而css是同步的 HTML解析器是不会等CSS解析完后在解析下面的HTML  ，

 我们要知道  style标签的样式是由html解析器解析的  所以啊 HTML又是异步的 这就导致了如果我们HTML解析完成，但是样式还没解析完成  这就会发生闪屏的现象  因为style是HTML解析的 他是异步的 （不阻塞）

而link引入的样式是同步的 ：他是由CSS解析器解析，他是同步的 他会阻塞页面的渲染 所以当我们HTML解析完成后，CSS还没解析完，全部都停住等他执行完（阻塞页面渲染）所以呢我们正好可以利用这一点来避免闪屏现象

关于css阻塞 ：只有link引入的外部css才能产生阻塞

   一、tyle标签的样式  

1. 由HTML解析器解析（异步）
2. 不阻塞页面的渲染
3. 不阻塞DOM解析

二、link引入的样式

 1.由CSS解析器解析（同步）

2. 阻塞页面渲染 
3. 阻塞后面js语句的执行
4. 不阻塞DOM的解析

对于上面的我猜你们会疑惑 为什么tyle 和link都不阻塞DOM解析呢？看了下面js的阻塞你就知道了

三、JS阻塞

 1.阻塞后续DOM解析 

（因为他能动样式 ，而css html是动不了样式的 ，你可以这样想 js引擎不阻塞DOM解析，如果先解析的是DOM而后面js又删除了后面的DOM这样是不是觉得浏览器做1无用功啊 ，浏览器不知道后面会又上面样的操作，索性全部停掉，等执行完在解析DOM）

2.阻塞页面渲染

  同上 js也可以操作样式

3.阻塞后续js执行



​       